// real main function that implements writing to all potentiometers
// this main function must include the STM32CubeIDE autogenerated code 
// the autogenerated code was left out for readability

/*user defined includes*/
#include "MUXEDPOTS_HPP.hpp"
#include "weights.hpp"

int main(){
    // --- Initialize the CS pin ---
      MuxedPots pot(&hspi1, GPIOA, GPIO_PIN_0); //initializes the CS pin
      pot.shutdownAll(); //reset all before writing

      // --- PotSet layer 1 ---
      for(uint8_t col = 1; col < 7; col++){
          for(uint8_t row = 1; row < 13; row++){
              if(row < 10)
                  pot.setBit(100+(10*col)+row, layer1_weights[row-1][col-1]);
              else
                  pot.setBit(1000+(100*col)+row, layer1_weights[row-1][col-1]);
          }
      }

      // --- PotSet layer 2 ---
      for(uint8_t col = 1; col < 7; col++){
          for(uint8_t row = 1; row < 7; row++){
              pot.setBit(200 + 10*col + row, layer2_weights[row-1][col-1]);
          }
      }

      // --- PotSet layer 3 ---
      for(uint8_t col = 1; col < 7; col++){
          for(uint8_t row = 1; row < 7; row++){
              pot.setBit(300 + 10*col + row, layer3_weights[row-1][col-1]);
          }
      }

      // --- PotSet layer 4 ---
      for(uint8_t col = 1; col < 7; col++){
          for(uint8_t row = 1; row < 7; row++){
              pot.setBit(400 + 10*col + row, layer4_weights[row-1][col-1]);
          }
      }

      // --- PotSet layer 5 ---
      for(uint8_t col = 1; col < 3; col++){
          for(uint8_t row = 1; row < 7; row++){
              pot.setBit(500 + 10*col + row, layer5_weights[row-1][col-1]);
          }
      }
}

// things to paste into main to check that any of the code is working
//pls work

//testing to see if multiplexer code for the cascading MUX
/*
uint8_t potInd = 0;
uint8_t muxInd = 0;
GPIOB->BSRR = (GPIO_PIN_12 | GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_15) << 16;

    //set new values for S0-S3
    GPIOB->BSRR = 
                ((potInd & 0x01) ? GPIO_PIN_12 : 0) |
                ((potInd & 0x02) ? GPIO_PIN_13 : 0) |
                ((potInd & 0x04) ? GPIO_PIN_14 : 0) |
                ((potInd & 0x08) ? GPIO_PIN_15 : 0);

    //clear S4-S7 on the GPIOA(PA8-PA11)
    GPIOA->BSRR = (GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11) << 16;
    
    //set new values for S4-S7
    GPIOA->BSRR = 
                ((muxInd & 0x01) ? GPIO_PIN_8 : 0) |
                ((muxInd & 0x02) ? GPIO_PIN_9 : 0) |
                ((muxInd & 0x04) ? GPIO_PIN_10 : 0) |
                ((muxInd & 0x08) ? GPIO_PIN_11 : 0);


	  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_RESET);
	  HAL_Delay(2000);
	  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_SET);
	  HAL_Delay(2000);
	  */

       /* THIS CODE WORKED TO UPDATE THE FIRST WIPER
  uint8_t potInd = 7;
  uint8_t muxInd = 0;

  GPIOB->BSRR = (GPIO_PIN_12 | GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_15) << 16;

      //set new values for S0-S3
      GPIOB->BSRR =
                  ((potInd & 0x01) ? GPIO_PIN_12 : 0) |
                  ((potInd & 0x02) ? GPIO_PIN_13 : 0) |
                  ((potInd & 0x04) ? GPIO_PIN_14 : 0) |
                  ((potInd & 0x08) ? GPIO_PIN_15 : 0);

      //clear S4-S7 on the GPIOA(PA8-PA11)
      GPIOA->BSRR = (GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11) << 16;

      //set new values for S4-S7
      GPIOA->BSRR =
                  ((muxInd & 0x01) ? GPIO_PIN_8 : 0) |
                  ((muxInd & 0x02) ? GPIO_PIN_9 : 0) |
                  ((muxInd & 0x04) ? GPIO_PIN_10 : 0) |
                  ((muxInd & 0x08) ? GPIO_PIN_11 : 0);

      uint8_t value = 20;
      uint8_t data[2] = {0b00010001, value}; //concatenating bit strings

          //executing any command is accomplished by setting CS low
          //then clocking-in a command byte followed by a data byte into
          //the 16-bit shift reg, the command is executed when CS is raised

          //resets cs low to begin data transfer
          HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_RESET);
          HAL_Delay(1);

          //sends the 16 bit command
          HAL_SPI_Transmit(&hspi1, data, 2, HAL_MAX_DELAY);
          HAL_Delay(1);
          //sets cs high to end the data transfer
          HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_SET);
          HAL_Delay(1);
          */